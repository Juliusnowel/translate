<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Referrer-Policy" content="no-referrer">
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">
  <meta http-equiv="Content-Security-Policy"
    content="default-src 'self';
            script-src 'self' 'unsafe-inline';
            connect-src 'self' https://libretranslate.com https://translate.astian.org https://libretranslate.de https://api.mymemory.translated.net;
            style-src 'self' 'unsafe-inline';
            img-src 'self' data:;
            frame-ancestors 'none';
            base-uri 'self';
            form-action 'self';">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HTML Translator</title>

  <style>
    /* Theme tokens (edit the accents to taste) */
    :root{
      --bg-1: #0f1724;         /* very dark base */
      --bg-2: #132032;         /* subtle gradient */
      --card: rgba(255,255,255,0.04);
      --card-2: rgba(255,255,255,0.03);
      --muted: rgba(255,255,255,0.65);
      --text: #ecf6ff;
      --accent-1: #4f46e5;     /* indigo */
      --accent-2: #06b6d4;     /* cyan */
      --success: #16a34a;
      --glass-border: rgba(255,255,255,0.06);
      --radius: 14px;
      --panel-gap: 28px;
    }

    /* Reset + page */
    * { box-sizing: border-box; }
    html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:var(--text); }
    body {
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:36px;
      background: linear-gradient(180deg,var(--bg-1), var(--bg-2));
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    h1{ margin:0 0 22px 0; font-size:32px; letter-spacing:-0.01em; font-weight:700; color:var(--text); text-align:center; }
    .subtitle { color:var(--muted); margin-bottom:18px; font-size:13px; }

    /* Layout: grid ensures perfect alignment & symmetric spacing */
    .container {
      width: min(1200px, 94%);
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--panel-gap);
      align-items:start; /* important — keeps headers baseline aligned */
    }

    /* Panel card */
    .panel {
      background: linear-gradient(180deg, var(--card), var(--card-2));
      border: 1px solid var(--glass-border);
      border-radius: calc(var(--radius));
      padding:16px;
      display:flex;
      flex-direction:column;
      min-height: 460px; /* guarantees equal visual height for both panels */
      box-shadow: 0 6px 24px rgba(2,6,23,0.45), inset 0 1px 0 rgba(255,255,255,0.02);
      transition: transform .18s ease;
    }
    .panel:hover { transform: translateY(-4px); }

    /* Header row inside each panel — consistent height prevents misalignment */
    .panel-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding-bottom:10px;
      border-bottom: 1px solid rgba(255,255,255,0.02);
      margin-bottom: 12px;
      min-height: 48px; /* equal header height across panels */
    }
    .panel-header h3 { margin:0; font-size:18px; color:var(--text); font-weight:600; }
    select {
      background: rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.06);
      color:var(--text);
      padding:6px 10px;
      border-radius:8px;
      font-size:13px;
      outline:none;
      min-width:150px;
    }

    /* Text area and output look consistent and aligned */
    textarea, .output-box {
      width:100%;
      height:320px;
      padding:14px;
      border-radius:12px;
      resize: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:15px;
      line-height:1.45;
      color:var(--text);
      background: rgba(0,0,0,0.24);
      border: 1px solid rgba(255,255,255,0.04);
      overflow:auto;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.45);
    }

    /* Make output visually distinct (lighter text + subtle accent on left) */
    .output-box {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    }

    /* Buttons row anchors at bottom so strong vertical rhythm */
    .btn-row {
      display:flex;
      justify-content:center;
      gap:14px;
      margin-top:16px;
    }
    .controls {
      display:flex;
      justify-content:center;
      gap:12px;
    }

    button {
      padding:10px 20px;
      border-radius:10px;
      border: none;
      color:white;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      transition: transform .12s ease, filter .12s ease, box-shadow .12s ease;
    }
    button:active { transform: translateY(1px); }

    #translateBtn {
      background: linear-gradient(90deg,var(--accent-1), var(--accent-2));
      min-width:150px;
    }
    #translateBtn:hover { filter:brightness(1.05); box-shadow: 0 10px 30px rgba(79,70,229,0.15); }

    #copyBtn {
      background: linear-gradient(90deg,#10b981,#059669);
      min-width:110px;
    }
    #copyBtn:hover { filter:brightness(1.03); box-shadow: 0 10px 30px rgba(6,182,212,0.12); }

    /* Small helpers */
    .muted { color:var(--muted); font-size:13px; text-align:center; margin-top:10px; }
    .footer { margin-top:22px; color:var(--muted); font-size:13px; text-align:center; width:100%; max-width:1200px; }

    /* Responsive fallback */
    @media (max-width:880px){
      .container{ grid-template-columns:1fr; gap:18px; }
      .panel { min-height:420px; }
    }
  </style>
</head>
<body>
  <h1>HTML Translator</h1>
  <div class="subtitle">Left stays English. Choose a target language on the right — fast, dark UI.</div>

  <div class="container">
    <div class="panel" id="leftPanel">
      <div class="panel-header">
        <h3>English</h3>
        <div class="muted">Source</div>
      </div>

      <textarea id="inputText" placeholder="Paste your HTML here...">hello</textarea>

      <div class="btn-row">
        <button id="translateBtn">Translate</button>
      </div>
    </div>

    <div class="panel" id="rightPanel">
      <div class="panel-header">
        <h3 id="targetLabel">Japanese</h3>
        <select id="targetLang" aria-label="Target language">
          <option value="ko">Korean (KO)</option>
          <option value="ja" selected>Japanese (JA)</option>
          <option value="zh">Chinese (ZH)</option>
          <option value="es">Spanish (ES)</option>
        </select>
      </div>

      <div id="outputText" class="output-box" aria-live="polite" role="region">こんにちは</div>

      <div class="btn-row">
        <button id="copyBtn">Copy</button>
      </div>
    </div>
  </div>

  <div class="footer">Tip: long inputs are chunked and cached to reduce rate-limit failures.</div>

  <script>
    // ---- Config ----
    const SOURCE = "en";
    let TARGET = "ko";
    const LANGS = { ko: "Korean", ja: "Japanese", zh: "Chinese", es: "Spanish" };
    const selector = document.getElementById('targetLang');
    const targetLabel = document.getElementById('targetLabel');

    selector.addEventListener('change', () => {
      targetLabel.textContent = LANGS[selector.value] || selector.value.toUpperCase();
      document.title = `HTML Translator (EN → ${targetLabel.textContent})`;
      document.getElementById('outputText').textContent = ''; // clear stale content
    });

    // ---- Providers ----
    const LT_ENDPOINTS = [
      "https://libretranslate.com/translate",
      "https://translate.astian.org/translate",
      "https://libretranslate.de/translate",
      "https://translate.argosopentech.com/translate",
      "https://translate.mentality.rip/translate",
      "https://translate.api.cloud.yourtranslator.app/translate",
      "https://libretranslate.pussthecat.org/translate"
    ];

    async function ltTranslate(text) {
      const payload = { q: text, source: SOURCE, target: TARGET, format: "text" };
      let lastErr;
      for (const url of LT_ENDPOINTS) {
        let delay = 250;
        for (let i = 0; i < 3; i++) {
          try {
            const r = await fetch(url, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            if (r.status === 429) { await new Promise(s => setTimeout(s, delay)); delay *= 2; continue; }
            if (!r.ok) throw new Error(url + " -> " + r.status);
            const data = await r.json();
            if (data?.translatedText) return data.translatedText;
            throw new Error("No translatedText");
          } catch (e) { lastErr = e; await new Promise(s => setTimeout(s, delay)); delay *= 2; }
        }
      }
      throw lastErr || new Error("LibreTranslate failed");
    }

    async function myMemoryTranslate(text) {
      const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${SOURCE}|${TARGET}&mtonly=1`;
      const r = await fetch(url);
      if (!r.ok) throw new Error("MyMemory HTTP " + r.status);
      const data = await r.json();

      const src = text.trim();
      const matches = Array.isArray(data?.matches) ? data.matches : [];
      const exact = matches.filter(m => (m.segment || "").trim() === src)
                           .sort((a,b) => (b.match||0) - (a.match||0));
      if (exact.length && (exact[0].match ?? 0) >= 0.80 && exact[0].translation) return exact[0].translation;

      const mt = matches.filter(m => m.translation && (m.reference || "").toLowerCase() === "machine translation")
                        .sort((a,b) => (b.match||0) - (a.match||0));
      if (mt.length) return mt[0].translation;

      const fallback = data?.responseData?.translatedText;
      if (fallback && fallback.trim()) return fallback;

      throw new Error("MyMemory returned low-quality/no match");
    }

    // ---- Cache + translate ----
    const cache = new Map();
    async function translateOne(text) {
      const key = `${SOURCE}→${TARGET}::${text.normalize('NFC')}`;
      if (cache.has(key)) return cache.get(key);
      try {
        const res = await ltTranslate(text);
        cache.set(key, res);
        return res;
      } catch (_) {
        const res = await myMemoryTranslate(text);
        cache.set(key, res);
        return res;
      }
    }

    async function translateBatch(texts) {
      const out = [];
      for (const t of texts) out.push(await translateOne(t));
      return out;
    }

    // ---- HTML walker ----
    async function translateHTML(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<div>${html}</div>`, "text/html");
      const wrapper = doc.body.firstElementChild;

      const textNodes = [];
      const attrNodes = [];
      const ATTRS = ["alt", "placeholder", "title", "aria-label"]; // safer: exclude "value"

      const walker = doc.createTreeWalker(wrapper, NodeFilter.SHOW_ALL, {
        acceptNode(node) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            if (tag === "style" || tag === "script") return NodeFilter.FILTER_REJECT;
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      });

      while (walker.nextNode()) {
        const node = walker.currentNode;

        if (node.nodeType === Node.TEXT_NODE) {
          const raw = node.textContent;
          if (/\S/.test(raw)) textNodes.push({ node, text: raw });
        }

        if (node.nodeType === Node.ELEMENT_NODE) {
          for (const a of ATTRS) {
            if (node.hasAttribute(a)) {
              const v = node.getAttribute(a).trim();
              if (v) attrNodes.push({ el: node, attr: a, text: v });
            }
          }
        }
      }

      const all = [...textNodes, ...attrNodes];
      const translated = await translateBatch(all.map(x => x.text));
      all.forEach((item, i) => {
        const t = translated[i] ?? "";
        if ("node" in item) item.node.textContent = t;
        else item.el.setAttribute(item.attr, t);
      });

      return wrapper.innerHTML;
    }

    // ---- UI wiring ----
    const targetLabel = document.getElementById("targetLabel");
    const pageTitle   = document.getElementById("pageTitle");
    const selector    = document.getElementById("targetLang");

    function syncHeadings() {
      const name = LANGS[TARGET] || TARGET.toUpperCase();
      targetLabel.textContent = name;
      document.title = `HTML Translator (EN → ${name.slice(0,2).toUpperCase()})`;
    }

    selector.addEventListener("change", () => {
      TARGET = selector.value;
      syncHeadings();
      document.getElementById("outputText").textContent = ""; // clear old result
    });

    document.getElementById("translateBtn").onclick = async () => {
      const html = document.getElementById("inputText").value.trim();
      if (!html) { alert("Please enter HTML content."); return; }
      const out = document.getElementById("outputText");
      out.innerHTML = "<em>Translating…</em>";
      try {
        const res = await translateHTML(html);
        out.textContent = res || "[No translatable text found]";
      } catch (e) {
        console.error(e);
        out.textContent = "Translation failed across providers (rate limit or CORS). Try again.";
      }
    };

    document.getElementById("copyBtn").onclick = async () => {
      const text = document.getElementById("outputText").textContent;
      await navigator.clipboard.writeText(text);
      const btn = document.getElementById("copyBtn");
      btn.textContent = "Copied!";
      setTimeout(() => (btn.textContent = "Copy"), 1500);
    };

    // init
    syncHeadings();
  </script>
</body>
</html>
