<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Referrer-Policy" content="no-referrer">
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">

  <meta http-equiv="Content-Security-Policy"
    content="default-src 'self';
            script-src 'self' 'unsafe-inline';
            connect-src 'self' https://libretranslate.com https://translate.astian.org https://libretranslate.de https://api.mymemory.translated.net;
            style-src 'self' 'unsafe-inline';
            img-src 'self' data:;
            frame-ancestors 'none';
            base-uri 'self';
            form-action 'self';">
  <title>HTML Translator (EN → KO)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; display: flex; flex-direction: column; align-items: center; background: #fafafa; }
    h1 { margin-bottom: 20px; font-weight: 600; color: #333; }
    .container { display: flex; gap: 40px; width: 90%; max-width: 1200px; }
    .panel { flex: 1; display: flex; flex-direction: column; align-items: center; }
    textarea, .output-box { width: 100%; height: 320px; font-family: monospace; font-size: 15px; padding: 12px; border: 1px solid #ccc; border-radius: 15px; background: #fff; resize: none; overflow: auto; white-space: pre-wrap; }
    .output-box { background: #f7f7f7; border-radius: 15px; }
    .btn-row { display: flex; justify-content: center; margin-top: 15px; gap: 15px; width: 100%; }
    button { padding: 10px 20px; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 15px; transition: background .2s; }
    #translateBtn { background: #007bff; width: 150px; } #translateBtn:hover { background: #0056b3; }
    #copyBtn { background: #28a745; width: 100px; } #copyBtn:hover { background: #1e7e34; }
  </style>
</head>
<body>
  <h1>HTML Translator</h1>
  <div class="container">
    <div class="panel">
      <h3>English</h3>
      <textarea id="inputText" placeholder="Paste your HTML here..."></textarea>
      <div class="btn-row">
        <button id="translateBtn">Translate</button>
      </div>
    </div>

    <div class="panel">
      <h3>Korean</h3>
      <div id="outputText" class="output-box"></div>
      <div class="btn-row">
        <button id="copyBtn">Copy</button>
      </div>
    </div>
  </div>

  <script>
    // ---------------- Free provider chain (no API keys) ----------------
    const SOURCE = "en";
    const TARGET = "ko";

    // Provider 1: LibreTranslate (several public instances; may rate-limit)
    const LT_ENDPOINTS = [
      "https://libretranslate.com/translate",
      "https://translate.astian.org/translate",
      "https://libretranslate.de/translate"
    ];

    async function ltTranslate(text) {
      const payload = { q: text, source: SOURCE, target: TARGET, format: "text" };
      let lastErr;
      for (const url of LT_ENDPOINTS) {
        let delay = 250;
        for (let i = 0; i < 3; i++) {
          try {
            const r = await fetch(url, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            if (r.status === 429) { await new Promise(s => setTimeout(s, delay)); delay *= 2; continue; }
            if (!r.ok) throw new Error(url + " -> " + r.status);
            const data = await r.json();
            if (data?.translatedText) return data.translatedText;
            throw new Error("No translatedText");
          } catch (e) { lastErr = e; await new Promise(s => setTimeout(s, delay)); delay *= 2; }
        }
      }
      throw lastErr || new Error("LibreTranslate failed");
    }


    // Provider 2: MyMemory (free, CORS-friendly, lighter quality but works)
    async function myMemoryTranslate(text) {
      const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${SOURCE}|${TARGET}&mtonly=1`;

      const r = await fetch(url);
      if (!r.ok) throw new Error("MyMemory HTTP " + r.status);
      const data = await r.json();

      // 1) Prefer exact segment matches with good scores
      const src = text.trim();
      const matches = Array.isArray(data?.matches) ? data.matches : [];
      const exact = matches
        .filter(m => (m.segment || "").trim() === src)
        .sort((a,b) => (b.match||0) - (a.match||0));

      if (exact.length && (exact[0].match ?? 0) >= 0.80 && exact[0].translation) {
        return exact[0].translation;
      }

      // 2) Otherwise prefer an MT candidate (not crowd memory) if present
      const mt = matches
        .filter(m => m.translation && (m.reference || "").toLowerCase() === "machine translation")
        .sort((a,b) => (b.match||0) - (a.match||0));
      if (mt.length) return mt[0].translation;

      // 3) Fall back to responseData but only if it’s not empty
      const fallback = data?.responseData?.translatedText;
      if (fallback && fallback.trim()) return fallback;

      throw new Error("MyMemory returned low-quality/no match");
    }


    // Smart single-phrase translate with fallback + tiny cache
    const cache = new Map();
    async function translateOne(text) {
      const key = `${SOURCE}→${TARGET}::${text.normalize('NFC')}`;
      if (cache.has(key)) return cache.get(key);
      try {
        const res = await ltTranslate(text);
        cache.set(key, res);
        return res;
      } catch (_) {
        const res = await myMemoryTranslate(text);
        cache.set(key, res);
        return res;
      }
    }

    // Batch helper (sequential to respect free limits; keeps UX predictable)
    async function translateBatch(texts) {
      const out = [];
      for (const t of texts) out.push(await translateOne(t));
      return out;
    }

    // ---------------- HTML translate core ----------------
    // Translate text nodes + attributes; keep <style>/<script> untouched.
    async function translateHTML(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<div>${html}</div>`, "text/html");
      const wrapper = doc.body.firstElementChild;

      const textNodes = [];
      const attrNodes = [];
      const ATTRS = ["alt", "placeholder", "title", "aria-label", "value"];

      // Skip style/script trees entirely
      const walker = doc.createTreeWalker(wrapper, NodeFilter.SHOW_ALL, {
        acceptNode(node) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            if (tag === "style" || tag === "script") return NodeFilter.FILTER_REJECT;
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      });

      while (walker.nextNode()) {
        const node = walker.currentNode;

        if (node.nodeType === Node.TEXT_NODE) {
          const raw = node.textContent;
          if (/\S/.test(raw)) textNodes.push({ node, text: raw });
        }

        if (node.nodeType === Node.ELEMENT_NODE) {
          for (const a of ATTRS) {
            if (node.hasAttribute(a)) {
              const v = node.getAttribute(a).trim();
              if (v) attrNodes.push({ el: node, attr: a, text: v });
            }
          }
        }
      }

      const all = [...textNodes, ...attrNodes];
      const translated = await translateBatch(all.map(x => x.text));
      all.forEach((item, i) => {
        const t = translated[i] ?? "";
        if ("node" in item) item.node.textContent = t;
        else item.el.setAttribute(item.attr, t);
      });

      // IMPORTANT: styles are preserved because we never touched/removed them
      return wrapper.innerHTML;
    }

    // ---------------- UI wiring ----------------
    document.getElementById("translateBtn").onclick = async () => {
      const html = document.getElementById("inputText").value.trim();
      if (!html) { alert("Please enter HTML content."); return; }
      const out = document.getElementById("outputText");
      out.innerHTML = "<em>Translating…</em>";
      try {
        const res = await translateHTML(html);
        out.textContent = res || "[No translatable text found]";
      } catch (e) {
        console.error(e);
        out.textContent = "Translation failed across providers (rate limit or CORS). Try again.";
      }
    };

    document.getElementById("copyBtn").onclick = async () => {
      const text = document.getElementById("outputText").textContent;
      await navigator.clipboard.writeText(text);
      const btn = document.getElementById("copyBtn");
      btn.textContent = "Copied!";
      setTimeout(() => (btn.textContent = "Copy"), 1500);
    };
  </script>
</body>
</html>
