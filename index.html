<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Referrer-Policy" content="no-referrer">
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">
  <meta http-equiv="Content-Security-Policy"
    content="default-src 'self';
            script-src 'self' 'unsafe-inline';
            connect-src 'self' https://libretranslate.com https://translate.astian.org https://libretranslate.de https://api.mymemory.translated.net;
            style-src 'self' 'unsafe-inline';
            img-src 'self' data:;
            frame-ancestors 'none';
            base-uri 'self';
            form-action 'self';">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* Theme tokens (edit the accents to taste) */
    :root{
      --bg-1: #0f1724;         /* very dark base */
      --bg-2: #132032;         /* subtle gradient */
      --card: rgba(255,255,255,0.04);
      --card-2: rgba(255,255,255,0.03);
      --muted: rgba(255,255,255,0.65);
      --text: #ecf6ff;
      --accent-1: #4f46e5;     /* indigo */
      --accent-2: #06b6d4;     /* cyan */
      --success: #16a34a;
      --glass-border: rgba(255,255,255,0.06);
      --radius: 14px;
      --panel-gap: 28px;
    }

    /* Reset + page */
    * { box-sizing: border-box; }
    html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:var(--text); }
    body {
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:36px;
      background: linear-gradient(180deg,var(--bg-1), var(--bg-2));
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    h1{ margin:0 0 22px 0; font-size:32px; letter-spacing:-0.01em; font-weight:700; color:var(--text); text-align:center; }
    .subtitle { color:var(--muted); margin-bottom:18px; font-size:13px; }

    /* Layout: grid ensures perfect alignment & symmetric spacing */
    .container {
      width: min(1200px, 94%);
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--panel-gap);
      align-items:start; /* important — keeps headers baseline aligned */
    }

    /* Panel card */
    .panel {
      background: linear-gradient(180deg, var(--card), var(--card-2));
      border: 1px solid var(--glass-border);
      border-radius: calc(var(--radius));
      padding:16px;
      display:flex;
      flex-direction:column;
      min-height: 460px; /* guarantees equal visual height for both panels */
      box-shadow: 0 6px 24px rgba(2,6,23,0.45), inset 0 1px 0 rgba(255,255,255,0.02);
      transition: transform .18s ease;
    }
    .panel:hover { transform: translateY(-4px); }

    /* Header row inside each panel — consistent height prevents misalignment */
    .panel-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding-bottom:10px;
      border-bottom: 1px solid rgba(255,255,255,0.02);
      margin-bottom: 12px;
      min-height: 48px; /* equal header height across panels */
    }
    .panel-header h3 { margin:0; font-size:18px; color:var(--text); font-weight:600; }
    /* Make the select match the dark UI and ensure options are readable */
    select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='10' viewBox='0 0 24 24'%3E%3Cpath fill='%23ecf6ff' d='M7 10l5 5 5-5z'/%3E%3C/svg%3E")
        no-repeat right 10px center;
      background-size: 14px 10px;
      padding: 6px 38px 6px 12px; 
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 8px;
      font-size: 13px;
      min-width: 150px;
      cursor: pointer;
    }

    /* Remove default IE dropdown arrow */
    select::-ms-expand { display: none; }

    /* Stronger focus ring for keyboard users */
    select:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(79,70,229,0.12);
      border-color: rgba(79,70,229,0.6);
    }

    /* Ensure option text is readable in dark theme (supported in most modern browsers) */
    select option {
      background: linear-gradient(180deg, var(--bg-2), var(--bg-1));
      color: var(--text);
      padding: 6px 8px;
    }

    /* Hover/selected styling inside the native dropdown where supported */
    select option:checked,
    select option:hover {
      background: linear-gradient(90deg, rgba(79,70,229,0.18), rgba(6,182,212,0.08));
      color: var(--text);
    }

    /* Custom select: visually consistent and fully stylable */
    .custom-select { position: relative; display:inline-block; min-width:150px; }
    .cs-btn {
      display:flex; align-items:center; justify-content:space-between;
      gap:8px;
      width:100%;
      background: rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.06);
      color:var(--text);
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    .cs-arrow { margin-left:8px; opacity:0.92; font-size:12px; }

    /* popup list */
    .cs-list {
      position:absolute;
      right:0;
      left:0;
      margin:8px 0 0 0;
      padding:6px 6px;
      list-style:none;
      border-radius:10px;
      background: linear-gradient(180deg,var(--bg-2),var(--bg-1));
      border:1px solid rgba(255,255,255,0.04);
      box-shadow: 0 10px 30px rgba(2,6,23,0.6);
      max-height:220px;
      overflow:auto;
      z-index:40;
      display:none; /* hidden until open */
    }
    .custom-select[data-open="true"] .cs-list { display:block; }

    /* items */
    .cs-item {
      padding:8px 10px;
      color:var(--text);
      border-radius:6px;
      cursor:pointer;
      font-size:14px;
    }
    .cs-item[aria-selected="true"] { background: linear-gradient(90deg, rgba(79,70,229,0.18), rgba(6,182,212,0.06)); }
    .cs-item:hover { background: rgba(255,255,255,0.03); }

    /* Text area and output look consistent and aligned */
    textarea, .output-box {
      width:100%;
      height:320px;
      padding:14px;
      border-radius:12px;
      resize: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size:15px;
      line-height:1.45;
      color:var(--text);
      background: rgba(0,0,0,0.24);
      border: 1px solid rgba(255,255,255,0.04);
      overflow:auto;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.45);
    }

    /* Make output visually distinct (lighter text + subtle accent on left) */
    .output-box {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    }

    /* Buttons row anchors at bottom so strong vertical rhythm */
    .btn-row {
      display:flex;
      justify-content:center;
      gap:14px;
      margin-top:16px;
    }
    .controls {
      display:flex;
      justify-content:center;
      gap:12px;
    }

    button {
      padding:10px 20px;
      border-radius:10px;
      border: none;
      color:white;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      transition: transform .12s ease, filter .12s ease, box-shadow .12s ease;
    }
    button:active { transform: translateY(1px); }

    #translateBtn {
      background: linear-gradient(90deg,var(--accent-1), var(--accent-2));
      min-width:150px;
    }
    #translateBtn:hover { filter:brightness(1.05); box-shadow: 0 10px 30px rgba(79,70,229,0.15); }

    #copyBtn {
      background: linear-gradient(90deg,#10b981,#059669);
      min-width:110px;
    }
    #copyBtn:hover { filter:brightness(1.03); box-shadow: 0 10px 30px rgba(6,182,212,0.12); }

    /* Small helpers */
    .muted { color:var(--muted); font-size:13px; text-align:center; margin-top:10px; }
    .footer { margin-top:22px; color:var(--muted); font-size:13px; text-align:center; width:100%; max-width:1200px; }

    /* Responsive fallback */
    @media (max-width:880px){
      .container{ grid-template-columns:1fr; gap:18px; }
      .panel { min-height:420px; }
    }
  </style>
</head>
<body>
  <h1>HTML Translator</h1>
  <div class="subtitle">Left stays English. Choose a target language on the right — fast, dark UI.</div>

  <div class="container">
    <div class="panel" id="leftPanel">
      <div class="panel-header">
        <h3>English</h3>
        <div class="muted">Source</div>
      </div>

      <textarea id="inputText" placeholder="Paste your HTML here..."></textarea>

      <div class="btn-row">
        <button id="translateBtn">Translate</button>
      </div>
    </div>

    <div class="panel" id="rightPanel">
      <div class="panel-header">
        <h3 id="targetLabel">Japanese</h3>
        <div class="custom-select" id="customSelect" data-open="false" aria-haspopup="listbox">
          <button class="cs-btn" id="csBtn" aria-expanded="false" aria-controls="csList">
            <span id="csLabel">Korean (KO)</span>
            <span class="cs-arrow">▾</span>
          </button>

          <ul class="cs-list" id="csList" role="listbox" tabindex="-1" aria-hidden="true">
            <li role="option" data-value="ko" class="cs-item" aria-selected="true">Korean (KO)</li>
            <li role="option" data-value="ja" class="cs-item">Japanese (JA)</li>
            <li role="option" data-value="zh" class="cs-item">Chinese (ZH)</li>
            <li role="option" data-value="es" class="cs-item">Spanish (ES)</li>
          </ul>

          <!-- hidden value that your existing code can still read -->
          <input type="hidden" id="targetLang" value="ko" />
        </div>
      </div>

      <div id="outputText" class="output-box" aria-live="polite" role="region"></div>

      <div class="btn-row">
        <button id="copyBtn">Copy</button>
      </div>
    </div>
  </div>

  <div class="footer">Tip: long inputs are chunked and cached to reduce rate-limit failures.</div>

  <script>
    // ---- Config ----
    const SOURCE = "en";
    let TARGET = "ko";
    const LANGS = { ko: "Korean", ja: "Japanese", zh: "Chinese", es: "Spanish" };
    const selector = document.getElementById('targetLang');
    const targetLabel = document.getElementById('targetLabel');

    selector.addEventListener('change', () => {
      targetLabel.textContent = LANGS[selector.value] || selector.value.toUpperCase();
      document.title = `HTML Translator (EN → ${targetLabel.textContent})`;
      document.getElementById('outputText').textContent = ''; // clear stale content
    });

    // ---- Providers ----
    const LT_ENDPOINTS = [
      "https://libretranslate.com/translate",
      "https://translate.astian.org/translate",
      "https://libretranslate.de/translate",
      "https://translate.argosopentech.com/translate",
      "https://translate.mentality.rip/translate",
      "https://translate.api.cloud.yourtranslator.app/translate",
      "https://libretranslate.pussthecat.org/translate"
    ];

    async function ltTranslate(text) {
      const payload = { q: text, source: SOURCE, target: TARGET, format: "text" };
      let lastErr;
      for (const url of LT_ENDPOINTS) {
        let delay = 250;
        for (let i = 0; i < 3; i++) {
          try {
            const r = await fetch(url, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            if (r.status === 429) { await new Promise(s => setTimeout(s, delay)); delay *= 2; continue; }
            if (!r.ok) throw new Error(url + " -> " + r.status);
            const data = await r.json();
            if (data?.translatedText) return data.translatedText;
            throw new Error("No translatedText");
          } catch (e) { lastErr = e; await new Promise(s => setTimeout(s, delay)); delay *= 2; }
        }
      }
      throw lastErr || new Error("LibreTranslate failed");
    }

    async function myMemoryTranslate(text) {
      const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${SOURCE}|${TARGET}&mtonly=1`;
      const r = await fetch(url);
      if (!r.ok) throw new Error("MyMemory HTTP " + r.status);
      const data = await r.json();

      const src = text.trim();
      const matches = Array.isArray(data?.matches) ? data.matches : [];
      const exact = matches.filter(m => (m.segment || "").trim() === src)
                           .sort((a,b) => (b.match||0) - (a.match||0));
      if (exact.length && (exact[0].match ?? 0) >= 0.80 && exact[0].translation) return exact[0].translation;

      const mt = matches.filter(m => m.translation && (m.reference || "").toLowerCase() === "machine translation")
                        .sort((a,b) => (b.match||0) - (a.match||0));
      if (mt.length) return mt[0].translation;

      const fallback = data?.responseData?.translatedText;
      if (fallback && fallback.trim()) return fallback;

      throw new Error("MyMemory returned low-quality/no match");
    }

    // ---- Cache + translate ----
    const cache = new Map();
    async function translateOne(text) {
      const key = `${SOURCE}→${TARGET}::${text.normalize('NFC')}`;
      if (cache.has(key)) return cache.get(key);
      try {
        const res = await ltTranslate(text);
        cache.set(key, res);
        return res;
      } catch (_) {
        const res = await myMemoryTranslate(text);
        cache.set(key, res);
        return res;
      }
    }

    async function translateBatch(texts) {
      const out = [];
      for (const t of texts) out.push(await translateOne(t));
      return out;
    }

    // ---- HTML walker ----
    async function translateHTML(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<div>${html}</div>`, "text/html");
      const wrapper = doc.body.firstElementChild;

      const textNodes = [];
      const attrNodes = [];
      const ATTRS = ["alt", "placeholder", "title", "aria-label"]; // safer: exclude "value"

      const walker = doc.createTreeWalker(wrapper, NodeFilter.SHOW_ALL, {
        acceptNode(node) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            if (tag === "style" || tag === "script") return NodeFilter.FILTER_REJECT;
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      });

      while (walker.nextNode()) {
        const node = walker.currentNode;

        if (node.nodeType === Node.TEXT_NODE) {
          const raw = node.textContent;
          if (/\S/.test(raw)) textNodes.push({ node, text: raw });
        }

        if (node.nodeType === Node.ELEMENT_NODE) {
          for (const a of ATTRS) {
            if (node.hasAttribute(a)) {
              const v = node.getAttribute(a).trim();
              if (v) attrNodes.push({ el: node, attr: a, text: v });
            }
          }
        }
      }

      const all = [...textNodes, ...attrNodes];
      const translated = await translateBatch(all.map(x => x.text));
      all.forEach((item, i) => {
        const t = translated[i] ?? "";
        if ("node" in item) item.node.textContent = t;
        else item.el.setAttribute(item.attr, t);
      });

      return wrapper.innerHTML;
    }

    // ---- UI wiring ----
    (function wireCustomSelect(){
      const cs = document.getElementById('customSelect');
      const btn = document.getElementById('csBtn');
      const list = document.getElementById('csList');
      const items = Array.from(list.querySelectorAll('.cs-item'));
      const label = document.getElementById('csLabel');
      const hidden = document.getElementById('targetLang');

      function openClose(open){
        cs.dataset.open = open ? "true" : "false";
        btn.setAttribute('aria-expanded', open ? 'true' : 'false');
        list.setAttribute('aria-hidden', open ? 'false' : 'true');
        if(open) list.focus();
      }

      // initial selection
      const initial = hidden.value || 'ko';
      const initialItem = items.find(i => i.dataset.value === initial);
      if(initialItem){
        items.forEach(it=>it.setAttribute('aria-selected','false'));
        initialItem.setAttribute('aria-selected','true');
        label.textContent = initialItem.textContent;
      }

      // toggle on button
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        openClose(cs.dataset.open !== "true");
      });

      // click on item
      items.forEach(it=>{
        it.addEventListener('click', (e)=>{
          const v = it.dataset.value;
          // update UI
          items.forEach(x=>x.setAttribute('aria-selected','false'));
          it.setAttribute('aria-selected','true');
          hidden.value = v;
          label.textContent = it.textContent;
          openClose(false);
          // trigger your existing change logic
          TARGET = v;
          if(typeof syncHeadings === 'function') syncHeadings();
          document.getElementById('outputText').textContent = '';
        });
      });

      // close when clicking outside
      document.addEventListener('click', ()=> openClose(false));
      // keyboard: basic support
      btn.addEventListener('keydown', (e)=>{
        if(e.key === 'ArrowDown' || e.key === 'Enter' || e.key === ' ') {
          e.preventDefault(); openClose(true);
        }
      });
      list.addEventListener('keydown', (e)=>{
        const idx = items.findIndex(i=>i.getAttribute('aria-selected')==='true');
        if(e.key === 'ArrowDown') { e.preventDefault(); const next = items[(idx+1)%items.length]; next.focus(); }
        if(e.key === 'ArrowUp') { e.preventDefault(); const prev = items[(idx-1+items.length)%items.length]; prev.focus(); }
        if(e.key === 'Enter') { document.activeElement.click(); }
        if(e.key === 'Escape') { openClose(false); btn.focus(); }
      });
    })();

    const pageTitle   = document.getElementById("pageTitle");

    function syncHeadings() {
      const name = LANGS[TARGET] || TARGET.toUpperCase();
      targetLabel.textContent = name;
      document.title = `HTML Translator (EN → ${name.slice(0,2).toUpperCase()})`;
    }

    selector.addEventListener("change", () => {
      TARGET = selector.value;
      syncHeadings();
      document.getElementById("outputText").textContent = ""; // clear old result
    });

    document.getElementById("translateBtn").onclick = async () => {
      const html = document.getElementById("inputText").value.trim();
      if (!html) { alert("Please enter HTML content."); return; }
      const out = document.getElementById("outputText");
      out.innerHTML = "<em>Translating…</em>";
      try {
        const res = await translateHTML(html);
        out.textContent = res || "[No translatable text found]";
      } catch (e) {
        console.error(e);
        out.textContent = "Translation failed across providers (rate limit or CORS). Try again.";
      }
    };

    document.getElementById("copyBtn").onclick = async () => {
      const text = document.getElementById("outputText").textContent;
      await navigator.clipboard.writeText(text);
      const btn = document.getElementById("copyBtn");
      btn.textContent = "Copied!";
      setTimeout(() => (btn.textContent = "Copy"), 1500);
    };

    // init
    syncHeadings();
    
  </script>
  
</body>
</html>
