<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Referrer-Policy" content="no-referrer">
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">
  <meta http-equiv="Content-Security-Policy"
    content="default-src 'self';
            script-src 'self' 'unsafe-inline';
            connect-src 'self' https://libretranslate.com https://translate.astian.org https://libretranslate.de https://api.mymemory.translated.net;
            style-src 'self' 'unsafe-inline';
            img-src 'self' data:;
            frame-ancestors 'none';
            base-uri 'self';
            form-action 'self';">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* Theme tokens (edit the accents to taste) */
    :root {
      --bg-1: #0f1724;         /* very dark base */
      --bg-2: #132032;         /* subtle gradient */
      --card: rgba(255,255,255,0.04);
      --card-2: rgba(255,255,255,0.03);
      --muted: rgba(255,255,255,0.65);
      --text: #ecf6ff;
      --accent-1: #4f46e5;     /* indigo */
      --accent-2: #06b6d4;     /* cyan */
      --success: #16a34a;
      --glass-border: rgba(255,255,255,0.06);
      --radius: 14px;
      --panel-gap: 28px;
    }

    /* Reset + page */
    * { box-sizing: border-box; }
    html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:var(--text); }
    body {
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:36px;
      background: linear-gradient(180deg,var(--bg-1), var(--bg-2));
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    h1 { margin:0 0 22px 0; font-size:32px; letter-spacing:-0.01em; font-weight:700; color:var(--text); text-align:center; }
    .subtitle { color:var(--muted); margin-bottom:18px; font-size:13px; }

    /* Layout: grid ensures perfect alignment & symmetric spacing */
    .container {
      width: min(1200px, 94%);
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--panel-gap);
      align-items:start; /* keep headers baseline aligned */
    }

    /* Panel card */
    .panel {
      background: linear-gradient(180deg, var(--card), var(--card-2));
      border: 1px solid var(--glass-border);
      border-radius: calc(var(--radius));
      padding:16px;
      display:flex;
      flex-direction:column;
      min-height: 460px; /* guarantees equal visual height for both panels */
      box-shadow: 0 6px 24px rgba(2,6,23,0.45), inset 0 1px 0 rgba(255,255,255,0.02);
      transition: transform .18s ease;
    }
    .panel:hover { transform: translateY(-4px); }

    /* Equal header height keeps panels aligned */
    .panel-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding-bottom:10px;
      border-bottom: 1px solid rgba(255,255,255,0.02);
      margin-bottom: 12px;
      min-height: 48px; /* equal header height across panels */
    }
    .panel-header h3 { margin:0; font-size:18px; color:var(--text); font-weight:600; }
    /* Make the select match the dark UI and ensure options are readable */
    select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='10' viewBox='0 0 24 24'%3E%3Cpath fill='%23ecf6ff' d='M7 10l5 5 5-5z'/%3E%3C/svg%3E")
        no-repeat right 10px center;
      background-size: 14px 10px;
      padding: 6px 38px 6px 12px; 
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 8px;
      font-size: 13px;
      min-width: 150px;
      cursor: pointer;
    }

    /* Remove default IE dropdown arrow */
    select::-ms-expand { display: none; }

    /* Stronger focus ring for keyboard users */
    select:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(79,70,229,0.12);
      border-color: rgba(79,70,229,0.6);
    }

    /* Ensure option text is readable in dark theme (supported in most modern browsers) */
    select option {
      background: linear-gradient(180deg, var(--bg-2), var(--bg-1));
      color: var(--text);
      padding: 6px 8px;
    }

    /* Hover/selected styling inside the native dropdown where supported */
    select option:checked,
    select option:hover {
      background: linear-gradient(90deg, rgba(79,70,229,0.18), rgba(6,182,212,0.08));
      color: var(--text);
    }

    /* Custom select: visually consistent and fully stylable */
    .custom-select {
      position: relative;
      display: inline-block;
      min-width: 150px;
    }
    .cs-btn {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      width: 100%;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
    }
    .cs-arrow {
      margin-left: 8px;
      opacity: 0.92;
      font-size: 12px;
    }

    /* popup list */
    .cs-list {
      position: absolute;
      right: 0;
      left: 0;
      margin: 8px 0 0 0;
      padding: 6px;
      list-style: none;
      border-radius: 10px;
      background: linear-gradient(180deg, var(--bg-2), var(--bg-1));
      border: 1px solid rgba(255, 255, 255, 0.04);
      box-shadow: 0 10px 30px rgba(2, 6, 23, 0.6);
      max-height: 220px;
      overflow: auto;
      z-index: 40;
      display: none; /* hidden until open */
    }
    .custom-select[data-open="true"] .cs-list { display: block; }

    /* items */
    .cs-item {
      padding: 8px 10px;
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    .cs-item[aria-selected="true"] { background: linear-gradient(90deg, rgba(79, 70, 229, 0.18), rgba(6, 182, 212, 0.06)); }
    .cs-item:hover { background: rgba(255, 255, 255, 0.03); }

    /* Text area and output look consistent and aligned */
    textarea,
    .output-box {
      width: 100%;
      height: 320px;
      padding: 14px;
      border-radius: 12px;
      resize: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 15px;
      line-height: 1.45;
      color: var(--text);
      background: rgba(0, 0, 0, 0.24);
      border: 1px solid rgba(255, 255, 255, 0.04);
      overflow: auto;
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.45);
    }

    /* Make output visually distinct (lighter text + subtle accent on left) */
    .output-box {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
    }

    /* Buttons row anchors at bottom so strong vertical rhythm */
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 14px;
      margin-top: 16px;
    }
    .controls {
      display: flex;
      justify-content: center;
      gap: 12px;
    }

    button {
      padding: 10px 20px;
      border-radius: 10px;
      border: none;
      color: white;
      cursor: pointer;
      font-weight: 600;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.45);
      transition: transform 0.12s ease, filter 0.12s ease, box-shadow 0.12s ease;
    }
    button:active { transform: translateY(1px); }

    #translateBtn {
      background: linear-gradient(90deg, var(--accent-1), var(--accent-2));
      min-width: 150px;
    }
    #translateBtn:hover { filter: brightness(1.05); box-shadow: 0 10px 30px rgba(79, 70, 229, 0.15); }

    #copyBtn {
      background: linear-gradient(90deg, #10b981, #059669);
      min-width: 110px;
    }
    #copyBtn:hover { filter: brightness(1.03); box-shadow: 0 10px 30px rgba(6, 182, 212, 0.12); }

    /* Small helpers */
    .muted { color: var(--muted); font-size: 13px; text-align: center; margin-top: 10px; }
    .footer { margin-top: 22px; color: var(--muted); font-size: 13px; text-align: center; width: 100%; max-width: 1200px; }

    /* Responsive fallback */
    @media (max-width: 880px) {
      .container { grid-template-columns: 1fr; gap: 18px; }
      .panel { min-height: 420px; }
    }
  </style>
</head>
<body>
  <h1>HTML Translator</h1>
  <div class="subtitle">Left stays English. Choose a target language on the right - fast, dark UI.</div>

  <div class="container">
    <div class="panel" id="leftPanel">
      <div class="panel-header">
        <h3>English</h3>
        <div class="muted">Source</div>
      </div>

      <textarea id="inputText" placeholder="Paste your HTML here..."></textarea>

      <div class="btn-row">
        <button id="translateBtn">Translate</button>
      </div>
    </div>

    <div class="panel" id="rightPanel">
      <div class="panel-header">
        <h3 id="targetLabel">Korean</h3>
        <div class="custom-select" id="customSelect" data-open="false" aria-haspopup="listbox">
          <button class="cs-btn" id="csBtn" aria-expanded="false" aria-controls="csList">
            <span id="csLabel">Korean (KO)</span>
            <span class="cs-arrow">&#9662;</span>
          </button>

          <ul class="cs-list" id="csList" role="listbox" tabindex="-1" aria-hidden="true">
            <li role="option" data-value="ko" class="cs-item" aria-selected="true" tabindex="0">Korean (KO)</li>
            <li role="option" data-value="ja" class="cs-item" tabindex="0">Japanese (JA)</li>
            <li role="option" data-value="zh" class="cs-item" tabindex="0">Chinese (ZH)</li>
            <li role="option" data-value="es" class="cs-item" tabindex="0">Spanish (ES)</li>
          </ul>

          <!-- hidden value that your existing code can still read -->
          <input type="hidden" id="targetLang" value="ko" />
        </div>
      </div>

      <div id="outputText" class="output-box" aria-live="polite" role="region"></div>

      <div class="btn-row">
        <button id="copyBtn">Copy</button>
      </div>
    </div>
  </div>

  <div class="footer">Tip: long inputs are chunked and cached to reduce rate-limit failures.</div>

  <script>
    const SOURCE_LANG = "en";
    const LANG_LABELS = { ko: "Korean", ja: "Japanese", zh: "Chinese", es: "Spanish" };
    const TRANSLATABLE_ATTRIBUTES = ["alt", "placeholder", "title", "aria-label"];
    const LIBRE_TRANSLATE_ENDPOINTS = [
      "https://libretranslate.com/translate",
      "https://translate.astian.org/translate",
      "https://libretranslate.de/translate",
      "https://translate.argosopentech.com/translate",
      "https://translate.mentality.rip/translate",
      "https://translate.api.cloud.yourtranslator.app/translate",
      "https://libretranslate.pussthecat.org/translate"
    ];

    const elements = {
      input: document.getElementById("inputText"),
      output: document.getElementById("outputText"),
      translateButton: document.getElementById("translateBtn"),
      copyButton: document.getElementById("copyBtn"),
      targetLabel: document.getElementById("targetLabel"),
      hiddenTarget: document.getElementById("targetLang"),
      customSelect: document.getElementById("customSelect"),
      customButton: document.getElementById("csBtn"),
      customList: document.getElementById("csList"),
      customLabel: document.getElementById("csLabel")
    };

    let targetLang = elements.hiddenTarget.value || "ko";
    let customItems = [];

    function labelFor(lang) {
      return LANG_LABELS[lang] || lang.toUpperCase();
    }

    function updateDocumentTitle(label) {
      document.title = `HTML Translator (EN -> ${label.slice(0, 2).toUpperCase()})`;
    }

    function updateCustomSelectState(lang) {
      if (!customItems.length) {
        return lang;
      }

      let selected = customItems.find(item => item.dataset.value === lang);
      if (!selected) {
        selected = customItems[0];
        lang = selected.dataset.value;
      }

      customItems.forEach(item => {
        const isSelected = item === selected;
        item.setAttribute("aria-selected", isSelected ? "true" : "false");
        item.tabIndex = isSelected ? 0 : -1;
      });

      if (selected) {
        elements.customLabel.textContent = selected.textContent;
      }

      return lang;
    }

    function updateTarget(lang) {
      if (!lang) {
        return;
      }

      const resolvedLang = updateCustomSelectState(lang);
      targetLang = resolvedLang;
      elements.hiddenTarget.value = resolvedLang;

      const label = labelFor(resolvedLang);
      elements.targetLabel.textContent = label;
      updateDocumentTitle(label);
      elements.output.textContent = "";
    }

    async function ltTranslate(text) {
      const payload = { q: text, source: SOURCE_LANG, target: targetLang, format: "text" };
      let lastErr;

      for (const url of LIBRE_TRANSLATE_ENDPOINTS) {
        let delay = 250;

        for (let attempt = 0; attempt < 3; attempt++) {
          try {
            const response = await fetch(url, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });

            if (response.status === 429) {
              await new Promise(resolve => setTimeout(resolve, delay));
              delay *= 2;
              continue;
            }

            if (!response.ok) {
              throw new Error(`${url} -> ${response.status}`);
            }

            const data = await response.json();
            if (data?.translatedText) {
              return data.translatedText;
            }

            throw new Error("No translatedText");
          } catch (error) {
            lastErr = error;
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2;
          }
        }
      }

      throw lastErr || new Error("LibreTranslate failed");
    }

    async function myMemoryTranslate(text) {
      const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${SOURCE_LANG}|${targetLang}&mtonly=1`;
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`MyMemory HTTP ${response.status}`);
      }

      const data = await response.json();
      const src = text.trim();
      const matches = Array.isArray(data?.matches) ? data.matches : [];

      const exact = matches
        .filter(match => (match.segment || "").trim() === src)
        .sort((a, b) => (b.match || 0) - (a.match || 0));
      if (exact.length && (exact[0].match ?? 0) >= 0.8 && exact[0].translation) {
        return exact[0].translation;
      }

      const machine = matches
        .filter(match => match.translation && (match.reference || "").toLowerCase() === "machine translation")
        .sort((a, b) => (b.match || 0) - (a.match || 0));
      if (machine.length) {
        return machine[0].translation;
      }

      const fallback = data?.responseData?.translatedText;
      if (fallback && fallback.trim()) {
        return fallback;
      }

      throw new Error("MyMemory returned low-quality/no match");
    }

    const cache = new Map();
    async function translateOne(text) {
      const cacheKey = `${SOURCE_LANG}->${targetLang}::${text.normalize("NFC")}`;
      if (cache.has(cacheKey)) {
        return cache.get(cacheKey);
      }

      try {
        const result = await ltTranslate(text);
        cache.set(cacheKey, result);
        return result;
      } catch (error) {
        const result = await myMemoryTranslate(text);
        cache.set(cacheKey, result);
        return result;
      }
    }

    async function translateBatch(texts) {
      const results = [];
      for (const text of texts) {
        results.push(await translateOne(text));
      }
      return results;
    }

    async function translateHTML(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<div>${html}</div>`, "text/html");
      const wrapper = doc.body.firstElementChild;

      const textNodes = [];
      const attributeNodes = [];

      const walker = doc.createTreeWalker(wrapper, NodeFilter.SHOW_ALL, {
        acceptNode(node) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            if (tag === "style" || tag === "script") {
              return NodeFilter.FILTER_REJECT;
            }
          }
          return NodeFilter.FILTER_ACCEPT;
        }
      });

      while (walker.nextNode()) {
        const node = walker.currentNode;

        if (node.nodeType === Node.TEXT_NODE) {
          const raw = node.textContent;
          if (/\S/.test(raw)) {
            textNodes.push({ node, text: raw });
          }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          for (const attribute of TRANSLATABLE_ATTRIBUTES) {
            if (node.hasAttribute(attribute)) {
              const value = node.getAttribute(attribute).trim();
              if (value) {
                attributeNodes.push({ element: node, attribute, text: value });
              }
            }
          }
        }
      }

      const targets = [...textNodes, ...attributeNodes];
      const translations = await translateBatch(targets.map(item => item.text));

      targets.forEach((item, index) => {
        const translatedText = translations[index] ?? "";
        if ("node" in item) {
          item.node.textContent = translatedText;
        } else {
          item.element.setAttribute(item.attribute, translatedText);
        }
      });

      return wrapper.innerHTML;
    }

    function wireCustomSelect() {
      customItems = Array.from(elements.customList.querySelectorAll(".cs-item"));

      function setOpen(open) {
        const isOpen = Boolean(open);
        elements.customSelect.dataset.open = isOpen ? "true" : "false";
        elements.customButton.setAttribute("aria-expanded", isOpen ? "true" : "false");
        elements.customList.setAttribute("aria-hidden", isOpen ? "false" : "true");

        if (isOpen) {
          const active = customItems.find(item => item.getAttribute("aria-selected") === "true") || customItems[0];
          (active || elements.customList).focus();
        }
      }

      elements.customButton.addEventListener("click", event => {
        event.stopPropagation();
        setOpen(elements.customSelect.dataset.open !== "true");
      });

      elements.customButton.addEventListener("keydown", event => {
        if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          setOpen(true);
        }
      });

      document.addEventListener("click", () => setOpen(false));

      customItems.forEach(item => {
        item.addEventListener("click", event => {
          event.preventDefault();
          updateTarget(item.dataset.value);
          setOpen(false);
          elements.customButton.focus();
        });
      });

      elements.customList.addEventListener("keydown", event => {
        const currentIndex = customItems.findIndex(item => item.getAttribute("aria-selected") === "true");

        if (event.key === "ArrowDown") {
          event.preventDefault();
          const next = customItems[(currentIndex + 1) % customItems.length];
          next.focus();
        } else if (event.key === "ArrowUp") {
          event.preventDefault();
          const prev = customItems[(currentIndex - 1 + customItems.length) % customItems.length];
          prev.focus();
        } else if (event.key === "Enter") {
          const focused = document.activeElement;
          const item = customItems.find(candidate => candidate === focused);
          if (item) {
            updateTarget(item.dataset.value);
            setOpen(false);
            elements.customButton.focus();
          }
        } else if (event.key === "Escape") {
          setOpen(false);
          elements.customButton.focus();
        }
      });
    }

    async function handleTranslate() {
      const html = elements.input.value.trim();
      if (!html) {
        alert("Please enter HTML content.");
        return;
      }

      elements.output.innerHTML = "<em>Translating...</em>";
      try {
        const result = await translateHTML(html);
        elements.output.textContent = result || "[No translatable text found]";
      } catch (error) {
        console.error(error);
        elements.output.textContent = "Translation failed across providers (rate limit or CORS). Try again.";
      }
    }

    async function handleCopy() {
      const text = elements.output.textContent;
      await navigator.clipboard.writeText(text);
      elements.copyButton.textContent = "Copied!";
      setTimeout(() => {
        elements.copyButton.textContent = "Copy";
      }, 1500);
    }

    elements.translateButton.addEventListener("click", handleTranslate);
    elements.copyButton.addEventListener("click", handleCopy);
    elements.hiddenTarget.addEventListener("change", event => updateTarget(event.target.value));

    wireCustomSelect();
    updateTarget(targetLang);
  </script>
  
</body>
</html>
